import { __decorate } from "tslib";
import { NgClass } from '@angular/common';
import { booleanAttribute, ChangeDetectionStrategy, Component, ElementRef, EventEmitter, forwardRef, Input, Optional, Output, ViewChildren, ViewEncapsulation } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { thumbMotion } from 'ng-zorro-antd/core/animation';
import { WithConfig } from 'ng-zorro-antd/core/config';
import { NzOutletModule } from 'ng-zorro-antd/core/outlet';
import { NzIconModule } from 'ng-zorro-antd/icon';
import { normalizeOptions } from './types';
import * as i0 from "@angular/core";
import * as i1 from "ng-zorro-antd/core/config";
import * as i2 from "@angular/cdk/bidi";
import * as i3 from "ng-zorro-antd/icon";
import * as i4 from "ng-zorro-antd/core/outlet";
const NZ_CONFIG_MODULE_NAME = 'segmented';
export class NzSegmentedComponent {
    constructor(nzConfigService, cdr, directionality) {
        this.nzConfigService = nzConfigService;
        this.cdr = cdr;
        this.directionality = directionality;
        this._nzModuleName = NZ_CONFIG_MODULE_NAME;
        this.nzBlock = false;
        this.nzDisabled = false;
        this.nzOptions = [];
        this.nzSize = 'default';
        this.nzLabelTemplate = null;
        this.nzValueChange = new EventEmitter();
        this.dir = 'ltr';
        this.selectedIndex = 0;
        this.transitionedToIndex = -1;
        this.animationState = null;
        this.normalizedOptions = [];
        this.destroy$ = new Subject();
        this.onChange = () => { };
        this.onTouched = () => { };
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe(direction => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
    }
    ngOnChanges(changes) {
        const { nzOptions } = changes;
        if (nzOptions) {
            this.normalizedOptions = normalizeOptions(nzOptions.currentValue);
        }
    }
    handleOptionClick(index) {
        if (this.nzDisabled) {
            return;
        }
        this.changeSelectedIndex(index);
        this.onChange(index);
        this.nzValueChange.emit(index);
    }
    handleThumbAnimationDone(e) {
        if (e.fromState === 'from') {
            this.selectedIndex = this.transitionedToIndex;
            this.transitionedToIndex = -1;
            this.animationState = null;
            this.cdr.detectChanges();
        }
    }
    writeValue(value) {
        if (typeof value === 'number' && value > -1) {
            this.changeSelectedIndex(value);
            this.cdr.markForCheck();
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    changeSelectedIndex(index) {
        if (!this.listOfOptions || this.selectedIndex === -1 || this.selectedIndex === index) {
            return;
        }
        this.animationState = {
            value: 'from',
            params: getThumbAnimationProps(this.listOfOptions.get(this.selectedIndex).nativeElement)
        };
        this.selectedIndex = -1;
        this.cdr.detectChanges();
        this.animationState = {
            value: 'to',
            params: getThumbAnimationProps(this.listOfOptions.get(index).nativeElement)
        };
        this.transitionedToIndex = index;
        this.cdr.detectChanges();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: NzSegmentedComponent, deps: [{ token: i1.NzConfigService }, { token: i0.ChangeDetectorRef }, { token: i2.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.0.1", type: NzSegmentedComponent, isStandalone: true, selector: "nz-segmented", inputs: { nzBlock: ["nzBlock", "nzBlock", booleanAttribute], nzDisabled: ["nzDisabled", "nzDisabled", booleanAttribute], nzOptions: "nzOptions", nzSize: "nzSize", nzLabelTemplate: "nzLabelTemplate" }, outputs: { nzValueChange: "nzValueChange" }, host: { properties: { "class.ant-segmented-disabled": "!!nzDisabled", "class.ant-segmented-rtl": "dir === 'rtl'", "class.ant-segmented-lg": "nzSize === 'large'", "class.ant-segmented-sm": "nzSize === 'small'", "class.ant-segmented-block": "!!nzBlock" }, classAttribute: "ant-segmented" }, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NzSegmentedComponent), multi: true }], viewQueries: [{ propertyName: "listOfOptions", predicate: ["itemLabels"], descendants: true, read: ElementRef }], exportAs: ["nzSegmented"], usesOnChanges: true, ngImport: i0, template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      @if (animationState) {
        <div
          [ngClass]="{ 'ant-segmented-thumb': true, 'ant-segmented-thumb-motion': true }"
          [@thumbMotion]="animationState"
          (@thumbMotion.done)="handleThumbAnimationDone($event)"
        ></div>
      }

      @for (item of normalizedOptions; track item; let i = $index) {
        <label
          #itemLabels
          [ngClass]="{
            'ant-segmented-item': true,
            'ant-segmented-item-selected': i === selectedIndex,
            'ant-segmented-item-disabled': !!nzDisabled || item.disabled
          }"
        >
          <input class="ant-segmented-item-input" type="radio" [checked]="i === selectedIndex" />
          <div class="ant-segmented-item-label" (click)="!item.disabled && handleOptionClick(i)">
            @if (item.icon) {
              <span class="ant-segmented-item-icon"><span nz-icon [nzType]="item.icon"></span></span>
              <span>
                <ng-container
                  *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
                >
                  {{ item.label }}
                </ng-container>
              </span>
            } @else {
              <ng-container
                *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
              >
                {{ item.label }}
              </ng-container>
            }
          </div>
        </label>
      }
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "ngmodule", type: NzIconModule }, { kind: "directive", type: i3.NzIconDirective, selector: "[nz-icon]", inputs: ["nzSpin", "nzRotate", "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], exportAs: ["nzIcon"] }, { kind: "ngmodule", type: NzOutletModule }, { kind: "directive", type: i4.NzStringTemplateOutletDirective, selector: "[nzStringTemplateOutlet]", inputs: ["nzStringTemplateOutletContext", "nzStringTemplateOutlet"], exportAs: ["nzStringTemplateOutlet"] }], animations: [thumbMotion], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
__decorate([
    WithConfig()
], NzSegmentedComponent.prototype, "nzSize", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: NzSegmentedComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    selector: 'nz-segmented',
                    exportAs: 'nzSegmented',
                    template: `
    <!-- thumb motion div -->
    <div class="ant-segmented-group">
      @if (animationState) {
        <div
          [ngClass]="{ 'ant-segmented-thumb': true, 'ant-segmented-thumb-motion': true }"
          [@thumbMotion]="animationState"
          (@thumbMotion.done)="handleThumbAnimationDone($event)"
        ></div>
      }

      @for (item of normalizedOptions; track item; let i = $index) {
        <label
          #itemLabels
          [ngClass]="{
            'ant-segmented-item': true,
            'ant-segmented-item-selected': i === selectedIndex,
            'ant-segmented-item-disabled': !!nzDisabled || item.disabled
          }"
        >
          <input class="ant-segmented-item-input" type="radio" [checked]="i === selectedIndex" />
          <div class="ant-segmented-item-label" (click)="!item.disabled && handleOptionClick(i)">
            @if (item.icon) {
              <span class="ant-segmented-item-icon"><span nz-icon [nzType]="item.icon"></span></span>
              <span>
                <ng-container
                  *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
                >
                  {{ item.label }}
                </ng-container>
              </span>
            } @else {
              <ng-container
                *nzStringTemplateOutlet="item.useTemplate && nzLabelTemplate; context: { $implicit: item, index: i }"
              >
                {{ item.label }}
              </ng-container>
            }
          </div>
        </label>
      }
    </div>
  `,
                    host: {
                        class: 'ant-segmented',
                        '[class.ant-segmented-disabled]': '!!nzDisabled',
                        '[class.ant-segmented-rtl]': `dir === 'rtl'`,
                        '[class.ant-segmented-lg]': `nzSize === 'large'`,
                        '[class.ant-segmented-sm]': `nzSize === 'small'`,
                        '[class.ant-segmented-block]': `!!nzBlock`
                    },
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NzSegmentedComponent), multi: true }],
                    animations: [thumbMotion],
                    imports: [NgClass, NzIconModule, NzOutletModule],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.NzConfigService }, { type: i0.ChangeDetectorRef }, { type: i2.Directionality, decorators: [{
                    type: Optional
                }] }], propDecorators: { listOfOptions: [{
                type: ViewChildren,
                args: ['itemLabels', { read: ElementRef }]
            }], nzBlock: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzDisabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], nzOptions: [{
                type: Input
            }], nzSize: [{
                type: Input
            }], nzLabelTemplate: [{
                type: Input
            }], nzValueChange: [{
                type: Output
            }] } });
function getThumbAnimationProps(element) {
    return {
        transform: element.offsetLeft,
        width: element.clientWidth
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VnbWVudGVkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2NvbXBvbmVudHMvc2VnbWVudGVkL3NlZ21lbnRlZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQU1BLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMxQyxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLHVCQUF1QixFQUV2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixVQUFVLEVBQ1YsS0FBSyxFQUVMLFFBQVEsRUFDUixNQUFNLEVBSU4sWUFBWSxFQUNaLGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUF1QixXQUFXLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUNoRixPQUFPLEVBQWdDLFVBQVUsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3JGLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUUzRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFbEQsT0FBTyxFQUFFLGdCQUFnQixFQUE4RCxNQUFNLFNBQVMsQ0FBQzs7Ozs7O0FBRXZHLE1BQU0scUJBQXFCLEdBQWdCLFdBQVcsQ0FBQztBQStEdkQsTUFBTSxPQUFPLG9CQUFvQjtJQWlDL0IsWUFDa0IsZUFBZ0MsRUFDL0IsR0FBc0IsRUFDVixjQUE4QjtRQUYzQyxvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7UUFDL0IsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFDVixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFuQ3BELGtCQUFhLEdBQWdCLHFC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dXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7IERpcmVjdGlvbiwgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBOZ0NsYXNzIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIGJvb2xlYW5BdHRyaWJ1dGUsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIGZvcndhcmRSZWYsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDaGlsZHJlbixcbiAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IFRodW1iQW5pbWF0aW9uUHJvcHMsIHRodW1iTW90aW9uIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL2FuaW1hdGlvbic7XG5pbXBvcnQgeyBOekNvbmZpZ0tleSwgTnpDb25maWdTZXJ2aWNlLCBXaXRoQ29uZmlnIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL2NvbmZpZyc7XG5pbXBvcnQgeyBOek91dGxldE1vZHVsZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS9vdXRsZXQnO1xuaW1wb3J0IHsgTnpTYWZlQW55LCBOelNpemVMRFNUeXBlLCBPbkNoYW5nZVR5cGUsIE9uVG91Y2hlZFR5cGUgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvdHlwZXMnO1xuaW1wb3J0IHsgTnpJY29uTW9kdWxlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9pY29uJztcblxuaW1wb3J0IHsgbm9ybWFsaXplT3B0aW9ucywgTnpOb3JtYWxpemVkT3B0aW9ucywgTnpTZWdtZW50ZWRPcHRpb24sIE56U2VnbWVudGVkT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBOWl9DT05GSUdfTU9EVUxFX05BTUU6IE56Q29uZmlnS2V5ID0gJ3NlZ21lbnRlZCc7XG5cbkBDb21wb25lbnQoe1xuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgc2VsZWN0b3I6ICduei1zZWdtZW50ZWQnLFxuICBleHBvcnRBczogJ256U2VnbWVudGVkJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8IS0tIHRodW1iIG1vdGlvbiBkaXYgLS0+XG4gICAgPGRpdiBjbGFzcz1cImFudC1zZWdtZW50ZWQtZ3JvdXBcIj5cbiAgICAgIEBpZiAoYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgPGRpdlxuICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJ2FudC1zZWdtZW50ZWQtdGh1bWInOiB0cnVlLCAnYW50LXNlZ21lbnRlZC10aHVtYi1tb3Rpb24nOiB0cnVlIH1cIlxuICAgICAgICAgIFtAdGh1bWJNb3Rpb25dPVwiYW5pbWF0aW9uU3RhdGVcIlxuICAgICAgICAgIChAdGh1bWJNb3Rpb24uZG9uZSk9XCJoYW5kbGVUaHVtYkFuaW1hdGlvbkRvbmUoJGV2ZW50KVwiXG4gICAgICAgID48L2Rpdj5cbiAgICAgIH1cblxuICAgICAgQGZvciAoaXRlbSBvZiBub3JtYWxpemVkT3B0aW9uczsgdHJhY2sgaXRlbTsgbGV0IGkgPSAkaW5kZXgpIHtcbiAgICAgICAgPGxhYmVsXG4gICAgICAgICAgI2l0ZW1MYWJlbHNcbiAgICAgICAgICBbbmdDbGFzc109XCJ7XG4gICAgICAgICAgICAnYW50LXNlZ21lbnRlZC1pdGVtJzogdHJ1ZSxcbiAgICAgICAgICAgICdhbnQtc2VnbWVudGVkLWl0ZW0tc2VsZWN0ZWQnOiBpID09PSBzZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgJ2FudC1zZWdtZW50ZWQtaXRlbS1kaXNhYmxlZCc6ICEhbnpEaXNhYmxlZCB8fCBpdGVtLmRpc2FibGVkXG4gICAgICAgICAgfVwiXG4gICAgICAgID5cbiAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJhbnQtc2VnbWVudGVkLWl0ZW0taW5wdXRcIiB0eXBlPVwicmFkaW9cIiBbY2hlY2tlZF09XCJpID09PSBzZWxlY3RlZEluZGV4XCIgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiYW50LXNlZ21lbnRlZC1pdGVtLWxhYmVsXCIgKGNsaWNrKT1cIiFpdGVtLmRpc2FibGVkICYmIGhhbmRsZU9wdGlvbkNsaWNrKGkpXCI+XG4gICAgICAgICAgICBAaWYgKGl0ZW0uaWNvbikge1xuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFudC1zZWdtZW50ZWQtaXRlbS1pY29uXCI+PHNwYW4gbnotaWNvbiBbbnpUeXBlXT1cIml0ZW0uaWNvblwiPjwvc3Bhbj48L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAgICpuelN0cmluZ1RlbXBsYXRlT3V0bGV0PVwiaXRlbS51c2VUZW1wbGF0ZSAmJiBuekxhYmVsVGVtcGxhdGU7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBpdGVtLCBpbmRleDogaSB9XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7eyBpdGVtLmxhYmVsIH19XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIH0gQGVsc2Uge1xuICAgICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKm56U3RyaW5nVGVtcGxhdGVPdXRsZXQ9XCJpdGVtLnVzZVRlbXBsYXRlICYmIG56TGFiZWxUZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6IGl0ZW0sIGluZGV4OiBpIH1cIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3sgaXRlbS5sYWJlbCB9fVxuICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIH1cbiAgICA8L2Rpdj5cbiAgYCxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnYW50LXNlZ21lbnRlZCcsXG4gICAgJ1tjbGFzcy5hbnQtc2VnbWVudGVkLWRpc2FibGVkXSc6ICchIW56RGlzYWJsZWQnLFxuICAgICdbY2xhc3MuYW50LXNlZ21lbnRlZC1ydGxdJzogYGRpciA9PT0gJ3J0bCdgLFxuICAgICdbY2xhc3MuYW50LXNlZ21lbnRlZC1sZ10nOiBgbnpTaXplID09PSAnbGFyZ2UnYCxcbiAgICAnW2NsYXNzLmFudC1zZWdtZW50ZWQtc21dJzogYG56U2l6ZSA9PT0gJ3NtYWxsJ2AsXG4gICAgJ1tjbGFzcy5hbnQtc2VnbWVudGVkLWJsb2NrXSc6IGAhIW56QmxvY2tgXG4gIH0sXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE56U2VnbWVudGVkQ29tcG9uZW50KSwgbXVsdGk6IHRydWUgfV0sXG4gIGFuaW1hdGlvbnM6IFt0aHVtYk1vdGlvbl0sXG4gIGltcG9ydHM6IFtOZ0NsYXNzLCBOekljb25Nb2R1bGUsIE56T3V0bGV0TW9kdWxlXSxcbiAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBOelNlZ21lbnRlZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICByZWFkb25seSBfbnpNb2R1bGVOYW1lOiBOekNvbmZpZ0tleSA9IE5aX0NPTkZJR19NT0RVTEVfTkFNRTtcblxuICBAVmlld0NoaWxkcmVuKCdpdGVtTGFiZWxzJywgeyByZWFkOiBFbGVtZW50UmVmIH0pIGxpc3RPZk9wdGlvbnMhOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG5cbiAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gIG56QmxvY2s6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgbnpEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBJbnB1dCgpIG56T3B0aW9uczogTnpTZWdtZW50ZWRPcHRpb25zID0gW107XG5cbiAgQElucHV0KCkgQFdpdGhDb25maWcoKSBuelNpemU6IE56U2l6ZUxEU1R5cGUgPSAnZGVmYXVsdCc7XG5cbiAgQElucHV0KCkgbnpMYWJlbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjx7ICRpbXBsaWNpdDogTnpTZWdtZW50ZWRPcHRpb247IGluZGV4OiBudW1iZXIgfT4gfCBudWxsID0gbnVsbDtcblxuICBAT3V0cHV0KCkgcmVhZG9ubHkgbnpWYWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIHB1YmxpYyBkaXI6IERpcmVjdGlvbiA9ICdsdHInO1xuXG4gIHB1YmxpYyBzZWxlY3RlZEluZGV4ID0gMDtcbiAgcHVibGljIHRyYW5zaXRpb25lZFRvSW5kZXggPSAtMTtcbiAgcHVibGljIGFuaW1hdGlvblN0YXRlOiBudWxsIHwgeyB2YWx1ZTogc3RyaW5nOyBwYXJhbXM6IFRodW1iQW5pbWF0aW9uUHJvcHMgfSA9IG51bGw7XG5cbiAgcHVibGljIG5vcm1hbGl6ZWRPcHRpb25zOiBOek5vcm1hbGl6ZWRPcHRpb25zID0gW107XG5cbiAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgb25DaGFuZ2U6IE9uQ2hhbmdlVHlwZSA9ICgpID0+IHt9O1xuXG4gIG9uVG91Y2hlZDogT25Ub3VjaGVkVHlwZSA9ICgpID0+IHt9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBuekNvbmZpZ1NlcnZpY2U6IE56Q29uZmlnU2VydmljZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSByZWFkb25seSBkaXJlY3Rpb25hbGl0eTogRGlyZWN0aW9uYWxpdHlcbiAgKSB7XG4gICAgdGhpcy5kaXJlY3Rpb25hbGl0eS5jaGFuZ2U/LnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoZGlyZWN0aW9uID0+IHtcbiAgICAgIHRoaXMuZGlyID0gZGlyZWN0aW9uO1xuICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGNvbnN0IHsgbnpPcHRpb25zIH0gPSBjaGFuZ2VzO1xuICAgIGlmIChuek9wdGlvbnMpIHtcbiAgICAgIHRoaXMubm9ybWFsaXplZE9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKG56T3B0aW9ucy5jdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU9wdGlvbkNsaWNrKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uekRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2VTZWxlY3RlZEluZGV4KGluZGV4KTtcblxuICAgIHRoaXMub25DaGFuZ2UoaW5kZXgpO1xuICAgIHRoaXMubnpWYWx1ZUNoYW5nZS5lbWl0KGluZGV4KTtcbiAgfVxuXG4gIGhhbmRsZVRodW1iQW5pbWF0aW9uRG9uZShlOiBOelNhZmVBbnkpOiB2b2lkIHtcbiAgICBpZiAoZS5mcm9tU3RhdGUgPT09ICdmcm9tJykge1xuICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy50cmFuc2l0aW9uZWRUb0luZGV4O1xuICAgICAgdGhpcy50cmFuc2l0aW9uZWRUb0luZGV4ID0gLTE7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gIH1cblxuICB3cml0ZVZhbHVlKHZhbHVlOiBudW1iZXIgfCBudWxsKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSkge1xuICAgICAgdGhpcy5jaGFuZ2VTZWxlY3RlZEluZGV4KHZhbHVlKTtcbiAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46IE9uQ2hhbmdlVHlwZSk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBPblRvdWNoZWRUeXBlKTogdm9pZCB7XG4gICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgfVxuXG4gIHByaXZhdGUgY2hhbmdlU2VsZWN0ZWRJbmRleChpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmxpc3RPZk9wdGlvbnMgfHwgdGhpcy5zZWxlY3RlZEluZGV4ID09PSAtMSB8fCB0aGlzLnNlbGVjdGVkSW5kZXggPT09IGluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IHtcbiAgICAgIHZhbHVlOiAnZnJvbScsXG4gICAgICBwYXJhbXM6IGdldFRodW1iQW5pbWF0aW9uUHJvcHModGhpcy5saXN0T2ZPcHRpb25zLmdldCh0aGlzLnNlbGVjdGVkSW5kZXgpIS5uYXRpdmVFbGVtZW50ISlcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcblxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSB7XG4gICAgICB2YWx1ZTogJ3RvJyxcbiAgICAgIHBhcmFtczogZ2V0VGh1bWJBbmltYXRpb25Qcm9wcyh0aGlzLmxpc3RPZk9wdGlvbnMuZ2V0KGluZGV4KSEubmF0aXZlRWxlbWVudCEpXG4gICAgfTtcbiAgICB0aGlzLnRyYW5zaXRpb25lZFRvSW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGh1bWJBbmltYXRpb25Qcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IFRodW1iQW5pbWF0aW9uUHJvcHMge1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHdpZHRoOiBlbGVtZW50LmNsaWVudFdpZHRoXG4gIH07XG59XG4iXX0=